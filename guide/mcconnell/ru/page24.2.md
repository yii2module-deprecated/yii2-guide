24.2. Разумные причины выполнения рефакторинга
==============

### Контрольный список

+ Код повторяется. 
+ Метод слишком велик. 
+ Цикл слишком велик или слишком глубоко вложен в другие циклы. 
+ Класс имеет плохую связность. 
+ Интерфейс класса не формирует согласованную абстракцию. 
+ Метод принимает слишком много параметров. 
+ Отдельные части класса изменяются независимо от других частей. 
+ При изменении программы требуется параллельно изменять несколько классов. 
+ Вам приходится параллельно изменять несколько иерархий наследования. 
+ Вам приходится параллельно изменять несколько блоков case. 
+ Родственные элементы данных, используемые вместе, не организованы в классы. 
+ Метод использует больше элементов другого класса, чем своего собственного. 
+ Элементарный тип данных перегружен. 
+ Класс имеет слишком ограниченную функциональность. 
+ По цепи методов передаются бродячие данные. 
+ Объект-посредник ничего не делает. 
+ Один класс слишком много знает о другом классе. 
+ Метод имеет неудачное имя. 
+ Данные-члены сделаны открытыми. 
+ Подкласс использует только малую долю методов своих предков. 
+ Сложный код объясняется при помощи комментариев. 
+ Код содержит глобальные переменные. 
+ Перед вызовом метода выполняется подготовительный код (после вызова метода выполняется код «уборки»). 
+ Программа содержит код, который может когда-нибудь понадобиться. 

### Когда не следует выполнять рефакторинг? 

Значение слова «рефакторинг» довольно размыто: так называют исправление дефектов, реализацию новой функциональности, модификацию проекта — по сути 
любое изменение кода. Это неуместно. Целенаправленный процесс изменений может 
быть эффективной стратегией, обеспечивающей постепенное повышение качества 
программы при ее сопровождении и предотвращающей всем известную смертельную спираль энтропии ПО, но само по себе изменение достоинств не имеет. 
