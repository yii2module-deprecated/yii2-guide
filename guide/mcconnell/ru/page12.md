12. Основные данные
==============

### Контрольный список

#### Числа в общем 

+ Не  содержит  ли  код  магические  числа?
+ Предупреждаются  ли  в  коде  ошибки  деления  на  ноль?
+ Очевидны  ли  преобразования  типов?
+ Если переменные двух разных типов используются в одном  выражении,  будет  ли  оно  вычислено  так,  как  вы  это предполагаете?
+ Не происходит ли сравнение переменных разных типов?
+ Компилируется ли программа без предупреждений компилятора?

#### Целые числа 

+ Работают ли выражения, содержащие целочисленное деление так, как это предполагалось? 
+ Предупреждаются ли в целочисленных выражениях проблемы целочисленного переполнения? 

#### Числа с плавающей запятой 

+ Не содержит ли код операции сложения и вычитания слишком разных по величине чисел? 
+ Предупреждаются ли в коде ошибки округления? 
+ Не выполняется сравнение на равенство чисел с плавающей запятой? 

#### Символы и строки 

+ Не содержит ли код магических символов и строк? 
+ Свободны ли операции со строками от ошибки потери единицы? 
+ Различаются ли в коде на C строковые указатели и массивы символов? 
+ Соблюдается ли в коде на C соглашение об объявлении строк с длиной CONSTANT+1? 
+ Используются ли в C массивы символов вместо указателей там, где это допустимо? 
+ Инициализируются ли в C строки с помощью NULL во избежание бесконечных строк? 
+ Используются ли в коде на C strncpy() вместо strcpy()? А strncat() и strncmp()? 

#### Логические переменные 

+ Используются ли в программе дополнительные логические переменные для документирования проверок условия? 
+ Используются ли в программе дополнительные логические переменные для упрощения проверок условия? 

#### Перечислимые  типы

+ Используются  ли  в  программе  перечислимые  типы  вместо  именованных констант  ради  их  улучшенной  читабельности,  надежности  и  модифицируемости?
+ Используются  ли  перечислимые  типы  вместо  логических  переменных,  если все  значения  переменной  не  могут  быть  переданы  с  помощью  true  и  false?
+ Проверяются  ли  некорректные  значения  перечислимых  типов  в  условных операторах?
+ Зарезервирован ли первый элемент перечислимого типа как недопустимый?

#### Перечислимые  константы

+ Используются  ли  в  программе  именованные  константы  вместо  магических чисел  для  объявления  данных  и  границ  циклов?
+ Используются  ли  именованные  константы  последовательно,  чтобы  одно значение  не  представлялось  в  одном  месте  константой,  а  в  другом  —  литералом?

#### Массивы

+ Находятся  ли  все  индексы  массива  в  его  границах?
+ Свободны  ли  ссылки  на  массив  от  ошибок  потери  единицы?
+ Указаны  ли  все  индексы  многомерных  массивов  в  правильном  порядке?
+ В правильном ли порядке используются переменные-индексы во вложенных циклах,  не  происходит  ли  пересечения  индексов?

#### Создание  типов

+ Используются  ли  в  программе  отдельные  типы  для  каждого  вида  данных, который  может  измениться?
+ Ориентируются  ли  имена  типов  на  реальные  сущности,  которые  эти  типы представляют,  а  не  на  типы  языка  программирования?
+ Достаточно  ли  наглядны  имена  типов,  чтобы  помочь  документированию объявлений  данных?
+ Не  произошло  ли  переопределение  предопределенных  типов?
+ Рассматривался  ли  вопрос  создания  нового  класса  вместо  простого  переопределения  типа?

### Ключевые моменты

+ Работа  с  определенными  типами  данных  требует  запоминания  множества правил для каждого из них. Используйте список контрольных вопросов из этой главы,  чтобы  убедиться,  что  вы  учли  основные  проблемы  с  ними.
+ Создание собственных типов, если ваш язык это позволяет, упрощает модификацию  вашей  программы  и  делает  ее  более  самодокументируемой.
+ Прежде  чем  создавать  простой  тип  с  помощью  typedef  или  его  эквивалента, подумайте,  не  следует  ли  создать  вместо  него  новый  класс.
